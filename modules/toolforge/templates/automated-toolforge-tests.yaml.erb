# this file is managed by puppet:
# modules/toolforge/templates/tests.yaml.erb
---
- envvars:
  - PROJECT: <%= @labsproject %>
    TOOLNAME: automated-toolforge-tests
    SUDO: sudo -niu <%= @labsproject %>.automated-toolforge-tests
    JOB_NAME: grid-test-script
    JOB_SCRIPT: ./grid-test-script.sh
    SCRIPT_FULLPATH: /data/project/automated-toolforge-tests/grid-test-script.sh
    WEBGENCODE_FULLPATH: /data/project/automated-toolforge-tests/www/python/src/app.py
    WEBGENCODE_ROOT: ./www
    WEBGENCODE_VENV: ./www/python/venv
    WEBGENCODE_SRC_DIR: ./www/python/src
    WEBLIGHTCODE_FULLPATH: /data/project/automated-toolforge-tests/public_html/app.py
    WEBLIGHTCODE_ROOT: ./public_html
    WEBLIGHTCODE_URL_COMPONENT: app.py
    VERIFY_TIMEOUT: "60"
    CRON_FILE: /data/project/automated-toolforge-tests/cron.txt
<% if @labsproject == 'toolsbeta' -%>
    # toolsbeta using special cloudstore VM NFS server
    NFS_PATH: /mnt/nfs/nfs-01-toolsbeta-project/automated-toolforge-tests
    TOOLFORGE_DOMAIN: toolsbeta.wmflabs.org
<% end -%>
<% if @labsproject == 'tools' -%>
    NFS_PATH: /mnt/nfs/labstore-secondary-tools-project/automated-toolforge-tests
    TOOLFORGE_DOMAIN: toolforge.org
<% end -%>
<% @envvars.each do |key, value| -%>
    <%= key %>: <%= value %>
<% end -%>
---
- name: verify the grid knows about this tool account
  tests:
    - cmd: $SUDO pwd | grep -q ${NFS_PATH}
      retcode: 0
      stderr: ""

- name: setup python webservice environment for the weblight grid
  tests:
    # cleanup previous executions
    - cmd: $SUDO rm -frv ${WEBLIGHTCODE_ROOT}
    - cmd: $SUDO mkdir -p ${WEBLIGHTCODE_ROOT}
      retcode: 0
      stderr: ""
      stdout: ""
    # create web app
    - cmd: |
           cat << EOF > ${WEBLIGHTCODE_FULLPATH}
           print(open('/etc/debian_version', 'r').read())
           EOF
      stdout: ""
      retcode: 0
      stderr: ""
    # ensure proper permissions
    - cmd: chown ${PROJECT}.${TOOLNAME}:${PROJECT}.${TOOLNAME} $WEBLIGHTCODE_FULLPATH
      retcode: 0
      stderr: ""
    - cmd: chmod ug+x $WEBLIGHTCODE_FULLPATH
      retcode: 0
      stderr: ""

- name: stretch python weblight grid reading /etc/debian_version (ws type lighttpd)
  tests:
    # cleanup previous executions
    - cmd: $SUDO webservice stop --backend gridengine
    # run the webapp (default is web light grid)
    - cmd: $SUDO webservice --backend gridengine --release stretch start | grep "Starting webservice"
      retcode: 0
      stderr: ""
    # verify: wait for the grid to schedule & run the webservice.
    - cmd: timeout $VERIFY_TIMEOUT bash -c -- '
           while ! curl -s https://${TOOLNAME}.${TOOLFORGE_DOMAIN}/${WEBLIGHTCODE_URL_COMPONENT} | grep ^9.
           ; do sleep 0.5 ; done'
      retcode: 0
      stderr: ""

- name: buster python weblight grid reading /etc/debian_version (ws type lighttpd)
  tests:
    # cleanup previous executions
    - cmd: $SUDO webservice stop --backend gridengine
    # leave room for the grid to stop stuff
    - cmd: sleep 10
    # run the webapp (default is web light grid)
    - cmd: $SUDO webservice --backend gridengine --release buster start | grep "Starting webservice"
      retcode: 0
      stderr: ""
    # verify: wait for the grid to schedule & run the webservice.
    - cmd: timeout $VERIFY_TIMEOUT bash -c -- '
           while ! curl -s https://${TOOLNAME}.${TOOLFORGE_DOMAIN}/${WEBLIGHTCODE_URL_COMPONENT} | grep ^10.
           ; do sleep 0.5 ; done'
      retcode: 0
      stderr: ""

# because the python venv, we can only schedule a flask webapp in this fashion:
#  * from a buster bastion into the buster grid
#  * from a stretch bastion into the stretch grid
- name: setup python webservice environment for the <%= @facts['os']['distro']['codename'] -%> webgen grid
  tests:
    - cmd: $SUDO rm -frv ${WEBGENCODE_ROOT} uwsgi.ini
    - cmd: $SUDO mkdir -p ${WEBGENCODE_SRC_DIR}
      retcode: 0
      stderr: ""
      stdout: ""
    # create uwsgi.ini config file
    - cmd: |
           cat << EOF > /data/project/${TOOLNAME}/uwsgi.ini
           [uwsgi]
           plugin = python3
           socket = /data/project/${TOOLNAME}/${TOOLNAME}.sock
           chdir = /data/project/${TOOLNAME}/www/python/src
           venv = /data/project/${TOOLNAME}/www/python/venv
           module = app
           callable = app
           manage-script-name = true
           mount = /=app:app
           EOF
      stdout: ""
      retcode: 0
      stderr: ""
    # create python venv
    - cmd: $SUDO bash -c -- 'python3 -m venv ${WEBGENCODE_VENV} ; source ${WEBGENCODE_VENV}/bin/activate ; pip install flask'
      retcode: 0
      stderr: ""
    # create web app
    - cmd: |
           cat << EOF > ${WEBGENCODE_FULLPATH}
           from flask import Flask, Response
           app = Flask(__name__)
           @app.route('/')
           def home():
             with open('/etc/debian_version', 'r') as f:
               return Response(f.read(), content_type="text/plain")
           EOF
      stdout: ""
      retcode: 0
      stderr: ""
    # ensure proper permissions
    - cmd: chown ${PROJECT}.${TOOLNAME}:${PROJECT}.${TOOLNAME} $WEBGENCODE_FULLPATH /data/project/${TOOLNAME}/uwsgi.ini
      retcode: 0
      stderr: ""
    - cmd: chmod ug+x $WEBGENCODE_FULLPATH
      retcode: 0
      stderr: ""

- name: <%= @facts['os']['distro']['codename'] -%> python webgen grid reading /etc/debian_version (ws type uwsgi-plain)
  tests:
    # cleanup
    - cmd: $SUDO webservice stop --backend gridengine
    # run the webapp
    - cmd: $SUDO webservice --backend gridengine --release <%= @facts['os']['distro']['codename'] -%> uwsgi-plain start | grep "Starting webservice"
      retcode: 0
      stderr: ""
    # verify: wait for the grid to schedule & run the webservice.
    - cmd: timeout $VERIFY_TIMEOUT bash -c -- '
           while ! curl -s https://${TOOLNAME}.${TOOLFORGE_DOMAIN}/ | grep ^<%= @facts['operatingsystemmajrelease'] -%>.
           ; do sleep 0.5 ; done'
      retcode: 0
      stderr: ""

- name: cleanup any remaining webservice in the grid
  tests:
    - cmd: $SUDO webservice stop --backend gridengine

- name: setup jsub env for later tests
  tests:
    # cleanup
    - cmd: $SUDO rm -fv ${JOB_SCRIPT} ${JOB_NAME}.err ${JOB_NAME}.out
    # create script reused by later tests
    - cmd: |
           cat << EOF > ${SCRIPT_FULLPATH}
           #!/bin/sh
           # autogenerated file by the toolforge test suite
           cat /etc/debian_version
           EOF
      stdout: ""
      retcode: 0
      stderr: ""
    # ensure proper permissions
    - cmd: chown ${PROJECT}.${TOOLNAME}:${PROJECT}.${TOOLNAME} $SCRIPT_FULLPATH
      retcode: 0
      stderr: ""
    - cmd: chmod ug+x $SCRIPT_FULLPATH
      retcode: 0
      stderr: ""

- name: verify default grid exec node release (stretch) if no release requested with jsub
  tests:
    # another cleanup
    - cmd: $SUDO rm -fv ${JOB_NAME}.err ${JOB_NAME}.out
    # run the job
    - cmd: $SUDO jsub ${JOB_SCRIPT} | grep ${JOB_NAME} | grep "has been submitted"
      retcode: 0
      stderr: ""
    # verify: wait for the grid to schedule & run the job
    - cmd: timeout $VERIFY_TIMEOUT bash -c -- '
           while ! $SUDO grep ^9. ${JOB_NAME}.out
           ; do sleep 0.5 ; done'
      retcode: 0
      stderr: ""
    # we should have no error messages
    - cmd: $SUDO cat ${JOB_NAME}.err | wc -l
      retcode: 0
      stderr: ""
      stdout: "0"

- name: run a basic jsub job in the BUSTER grid reading /etc/debian_version of the exec node
  tests:
    # another cleanup
    - cmd: $SUDO rm -fv ${JOB_NAME}.err ${JOB_NAME}.out
    # run the job
    - cmd: $SUDO jsub -release buster ${JOB_SCRIPT} | grep ${JOB_NAME} | grep "has been submitted"
      retcode: 0
      stderr: ""
    # verify: wait for the grid to schedule & run the job
    - cmd: timeout $VERIFY_TIMEOUT bash -c -- '
           while ! $SUDO grep ^10. ${JOB_NAME}.out
           ; do sleep 0.5 ; done'
      retcode: 0
      stderr: ""
    # we should have no error messages
    - cmd: $SUDO cat ${JOB_NAME}.err | wc -l
      retcode: 0
      stderr: ""
      stdout: "0"

- name: run a basic jsub job in the STRETCH grid reading /etc/debian_version of the exec node
  tests:
    # another cleanup
    - cmd: $SUDO rm -fv ${JOB_NAME}.err ${JOB_NAME}.out
    # run the job
    - cmd: $SUDO jsub -release stretch ${JOB_SCRIPT} | grep ${JOB_NAME} | grep "has been submitted"
      retcode: 0
      stderr: ""
    # verify: wait for the grid to schedule & run the job
    - cmd: timeout $VERIFY_TIMEOUT bash -c -- '
           while ! $SUDO grep ^9. ${JOB_NAME}.out
           ; do sleep 0.5 ; done'
      retcode: 0
      stderr: ""
    # we should have no error messages
    - cmd: $SUDO cat ${JOB_NAME}.err | wc -l
      retcode: 0
      stderr: ""
      stdout: "0"

- name: setup environment for a cron job, default stretch grid
  tests:
    # start fresh
    - cmd: $SUDO crontab -r
    - cmd: $SUDO qdel -f \*
    - cmd: $SUDO rm ${JOB_NAME}.out ${JOB_NAME}.err
    # a basic cron file
    - cmd: |
           cat << EOF > ${CRON_FILE}
           # autogenerated file by the toolforge test suite
           * * * * * jsub -quiet ${SCRIPT_FULLPATH}
           EOF
      retcode: 0
      stderr: ""
      stdout: ""
    # ensure proper permissions
    - cmd: chown ${PROJECT}.${TOOLNAME}:${PROJECT}.${TOOLNAME} ${CRON_FILE}
      retcode: 0
      stderr: ""

- name: basic cron job, default stretch grid
  tests:
    - cmd: $SUDO crontab ${CRON_FILE}
      retcode: 0
      stdout: ""
    # verify: wait at least 1 minute for the cron to trigger, then for the grid to schedule & run the job
    - cmd: timeout 120 bash -c -- '
           while ! $SUDO grep ^9. ${JOB_NAME}.out
           ; do sleep 0.5 ; done'
      retcode: 0
    # we should have no error messages
    - cmd: $SUDO cat ${JOB_NAME}.err | wc -l
      retcode: 0
      stderr: ""
      stdout: "0"

- name: setup environment for a cron job, buster grid
  tests:
    # start fresh
    - cmd: $SUDO crontab -r
    - cmd: $SUDO qdel -f \*
    - cmd: $SUDO rm ${JOB_NAME}.out ${JOB_NAME}.err
    # a basic cron file
    - cmd: |
           cat << EOF > ${CRON_FILE}
           # autogenerated file by the toolforge test suite
           * * * * * jsub -quiet -release buster ${SCRIPT_FULLPATH}
           EOF
      retcode: 0
      stderr: ""
      stdout: ""
    # ensure proper permissions
    - cmd: chown ${PROJECT}.${TOOLNAME}:${PROJECT}.${TOOLNAME} ${CRON_FILE}
      retcode: 0
      stderr: ""

- name: basic cron job, buster grid
  tests:
    - cmd: $SUDO crontab ${CRON_FILE}
      retcode: 0
      stdout: ""
    # verify: wait at least 1 minute for the cron to trigger, then for the grid to schedule & run the job
    - cmd: timeout 120 bash -c -- '
           while ! $SUDO grep ^10. ${JOB_NAME}.out
           ; do sleep 0.5 ; done'
      retcode: 0
    # we should have no error messages
    - cmd: $SUDO cat ${JOB_NAME}.err | wc -l
      retcode: 0
      stderr: ""
      stdout: "0"
    - cmd: $SUDO rm ${JOB_NAME}.out ${JOB_NAME}.err

- name: cleanup any remaining cron job
  tests:
    - cmd: $SUDO crontab -r
      retcode: 0
