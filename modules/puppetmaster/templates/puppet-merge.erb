#!/bin/sh

<%- if @facts['networking']['fqdn'] != @ca_server -%>
printf "To ensure consistent locking please run puppet-merge from: %s\n" <%= @ca_server %>
exit 1
<%- end -%>
set -eu
git_user=gitpuppet
if [ "$(whoami)" = "gitpuppet" ]
then
  printf "This script should only be run as a real users.  gitpuppet should use /usr/local/bin/puppet-merge.py\n"
  exit 1
fi

lock() {
  LABS_PRIVATE=$1
  if [ ${LABS_PRIVATE} -eq 1 ]
  then
    LOCKFILE=/var/lock/puppet-merge-labs-lock
  else
    LOCKFILE=/var/lock/puppet-merge-prod-lock
  fi
  LOCKFD=9
  eval "exec ${LOCKFD}>\"$LOCKFILE\""
  trap "rm -f $LOCKFILE" EXIT
  if ! flock -xn $LOCKFD
  then
      trap EXIT
      # Close our own fd to the lockfile before checking ownership below.
      eval "exec ${LOCKFD}>&-"
      # Any subprocess of the script that holds the lock will also have an open
      # filehandle to $LOCKFILE.  Grab just one such PID for pstree (doesn't
      # matter which).
      PSTREE=$(pstree -su $(fuser $LOCKFILE 2>/dev/null | awk '{print $1}'))
      # If given an empty command line, or a nonexistent PID, pstree -su will
      # output all processes on the system, which isn't helpful.  Normal usage
      # of this script should only ever yield a single line of pstree output.
      if [ $(echo "$PSTREE" | wc -l) -eq 1 ]
      then
        PSTREE="locking process tree: $PSTREE"
      else
        PSTREE="could not determine lock holder"
      fi
      printf "E: failed to lock, another puppet-merge running on this host?\n%s\n" "${PSTREE}" >&2
      exit 1
  fi
}
check_remote_error() {
  exit_code=$1
  worker=$2
  repo=$3
  RED=$(tput bold; tput setaf 1)
  GREEN=$(tput bold; tput setaf 2)
  CYAN=$(tput bold; tput setaf 6)
  RESET=$(tput sgr0)
  if [ ${exit_code} -eq 0 ]; then
    echo "${GREEN}OK${RESET}: puppet-merge on ${worker} (${repo}) succeeded"
  elif [ ${exit_code} -eq 99 ]; then
    echo "${CYAN}NO CHANGE${RESET}: puppet-merge on ${worker} (${repo}) no change"
  else
    echo "${RED}ERROR${RESET}: puppet-merge on ${worker} (${repo}) failed"
  fi
}

FORCE=0
USAGE=0
QUIET=0
LABS_PRIVATE=0
DIFF_ONLY=0

usage="$(basename ${0}) [-y|--yes] [SHA1]

Fetches changes from origin and from all submodules.
Shows diffs between HEAD and FETCH_HEAD, including diffs
of submodule changes.

If the changes are acceptable, HEAD will be fast-forwarded
to FETCH_HEAD.

It also runs the conftool merge if necessary.

SHA1 equals HEAD if not specified
"
# preserve arguments before we shift them all
ORIG_ARGS="$@"
TEMP=$(getopt -o yhqd --long yes,help,quiet,labsprivate,diffs -n "$0" -- "$@")
if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi

eval set -- "$TEMP"
while true; do
    case "$1" in
        -y|--yes) FORCE=1; shift ;;
        -h|--help) USAGE=1; shift ;;
        -q|--quiet) QUIET=1; shift ;;
        -d|--diffs) DIFF_ONLY=1; shift ;;
        -p|--labsprivate) LABS_PRIVATE=1; shift ;;
        --) shift ; break ;;
        *) echo "Internal error!"; exit 1 ;;
    esac
done

if [ $USAGE -eq 1 ]; then
    echo "$usage" && exit 0;
fi

lock $LABS_PRIVATE

# From this point continue despite errors on remote masters. After a change
# has been merged on the local master a remote merge failure should not
# cause all remaining masters to be aborted and left out of sync.
set +e

if [ $LABS_PRIVATE -eq 1 ]; then
    # if --labsprivate is used just sync the labsprivate repo
    /usr/local/bin/puppet-merge.py  "$ORIG_ARGS"
    LABS_EXIT=$?
    # fake the production exit
    PROD_EXIT=99
else
    # We want to do a labs merge every time we do an ops merge
    /usr/local/bin/puppet-merge.py --labsprivate $ORIG_ARGS
    LABS_EXIT=$?
    /usr/local/bin/puppet-merge.py --ops $ORIG_ARGS
    PROD_EXIT=$?
fi
# puppet-merge.py exits with 99 if no merge was performed
if [ ${PROD_EXIT} -eq 99 -a ${LABS_EXIT} -eq 99 ]; then
  exit 0
elif [ ${PROD_EXIT} -ne 0 -a ${PROD_EXIT} -ne 99 ]; then
  printf 'problems merging production'
  exit ${PROD_EXIT}
elif [ ${LABS_EXIT} -ne 0 -a ${LABS_EXIT} -ne 99 ]; then
  printf 'problems merging LABS'
  exit ${LABS_EXIT}
fi

# Note: The "true" command is passed on purpose to show that the command passed
# to the SSH sessions is irrelevant. It's the SSH forced command trick on the
# worker end that does the actual work. Note that args (including
# the $sha1 and possible --labsprivate switch) are used.
<%-
workers = @servers.values.map do |workers_map|
  workers_map.map { |name| name['worker'] }.select { |name| name != @fqdn }.flatten
end
-%>
for worker in <%= workers.join(' ') %>; do
  if [ $LABS_PRIVATE -eq 1 ]; then
    su - $git_user -c "ssh -t -t ${worker} true --labsprivate ${1:-} 2>&1"
    check_remote_error $? ${worker} 'labs'
  else
    su - $git_user -c "ssh -t -t ${worker} true --ops ${1:-} 2>&1"
    check_remote_error $? ${worker} 'ops'
    su - $git_user -c "ssh -t -t ${worker} true --labsprivate ${1:-} 2>&1"
    check_remote_error $? ${worker} 'labs'
  fi
done

# Only run this once, and only if we're merging the prod repo
if [ $LABS_PRIVATE -eq 0 ]; then
    echo "Now running conftool-merge to sync any changes to conftool data"
    /usr/local/bin/conftool-merge
fi
# vim: set syntax=sh:
