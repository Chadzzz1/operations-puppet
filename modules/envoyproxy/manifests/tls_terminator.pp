# @summary
#   Configure envoy to be a TLS proxy to local services.
#   It's thought as a simple shoe-in replacement for tlsproxy::localssl
#   in limited use-cases for internal usage.
#
# @example Set up a simple TLS termination for an upstream serving on port 80
#   envoyproxy::tls_terminator { 'scb':
#     tls_port  => 443,
#     upstreams => [{
#       server_names => ['citoid.svc.eqiad.wmnet', 'citoid'],
#       cert_path    => '/etc/ssl/localcerts/citoid.crt',
#       key_path     => '/etc/ssl/localcerts/citoid.key',
#       upstream_port => 1234
#     },
#     {
#       server_names => ['pdfrenderer.svc.eqiad.wmnet', 'pdfrenderer'],
#       cert_path    => '/etc/ssl/localcerts/evil.crt',
#       key_path     => '/etc/ssl/localcerts/evil.key',
#       upstream_port => 666
#     }],
#     connect_timeout => 0.25,
#     global_cert_path => '/etc/ssl/localcerts/services.crt',
#     global_cert_key  => '/etc/ssl/localcert/services.key'
#   }
#
# @example Set up non-sni only termination to backends
#   envoyproxy::tls_terminator { 'scb':
#     tls_port  => 443,
#     upstreams => [{
#       server_names => ['citoid.svc.eqiad.wmnet', 'citoid'],
#       upstream_port => 1234
#     },
#     {
#       server_names => ['pdfrenderer.svc.eqiad.wmnet', 'pdfrenderer'],
#       upstream_port => 666
#     }],
#     connect_timeout => 0.25,
#     global_cert_path => '/etc/ssl/localcerts/services.crt',
#     global_cert_key  => '/etc/ssl/localcert/services.key'
#   }
# @example Set up TLS global proxying in front of apache
#   envoyproxy::tls_terminator { 'scb':
#     tls_port  => 443,
#     upstreams => [{
#       server_names => ['*'],
#       upstream_port => 80B
#     },
#     connect_timeout => 0.25,
#     global_cert_path => '/etc/ssl/localcerts/services.crt',
#     global_cert_key  => '/etc/ssl/localcert/services.key'
#   }
#
# @param upstreams
#   A list of Envoyproxy::Tlsconfig structures defining the upstream
#   server configurations. A non-SNI default catchall will be autogenerated.
# @param tls_port
#   Port on which to accept TLS-encrypted requests. Defaults to port 443
# @param redir_port
#     TCP port to listen on as plain HTTP.  This listener will redirect
#     GET/HEAD to HTTPS with 301 and deny all other methods with 403.  It does
#     not proxy any traffic. If undefined, no HTTP redirect will be created.
#     Default is undefined.
# @param access_log
#     If true, sets up the access log for the TLS terminator.
# @param connect_timeout
#     The time is seconds to wait before declaring a connection timeout to the
#     upstream resource
define envoyproxy::tls_terminator(
  Array[Envoyproxy::Tlsconfig] $upstreams = [],
    Optional[Stdlib::Port] $redir_port = undef,
    Boolean $access_log = false,
    Float $connect_timeout = 1.0,
    Optional[String] $global_cert_path = undef,
    Optional[String] $global_key_path = undef
) {

    # First of all, we can't configure a tls terminator if envoy is not installed.
    if !defined(Class['envoyproxy']) {
        fail('envoyproxy::tls_terminator should only be used once the envoyproxy class is declared.')
    }

    # As this is a fundamental function, install it with high priority
    # Please note they will be removed if we remove the terminator declaration.
    #
    # Please note: envoy will NOT be restarted automatically.
    envoyproxy::cluster { "cluster_local_tls_${name}":
        priority => 0,
        content  => template('envoyproxy/tls_terminator/cluster.yaml.erb'),
    }
    envoyproxy::listener { "tls_terminator_${name}":
        priority => 0,
        content  => template('envoyproxy/tls_terminator/listener.yaml.erb'),
    }
    if $redir_port {
        # Redirection is less important, install it at the bottom of the pyle.
        envoyproxy::listener { "http_redirect_${name}":
            priority => 99,
            content  => template('envoyproxy/tls_terminator/redirect_listener.yaml.erb')
        }
    }
}
